name: Linux Build

on:
  push:
    paths:
      - '**/*'
      - '!appveyor.yml'
      - '!README.md'
      - '!doc/**'
      - '!**/.github/**' # Simplificado
      - '.github/workflows/workflow_linux.yml'
  pull_request:
    paths:
      - '**/*'
      - '!appveyor.yml'
      - '!README.md'
      - '!doc/**'
      - '!.github/**' # Simplificado
      - '.github/workflows/workflow_linux.yml'

jobs:
  Ubuntu:
    runs-on: ubuntu-24.04
    env:
      GIT_LFS_SKIP_SMUDGE: '1'
    timeout-minutes: 120 # Previene cancelación por tiempo
    strategy:
      fail-fast: false # Permite que si uno falla, el otro (gcc/clang) siga
      matrix:
        compiler: [gcc, clang]
        include:
          - compiler: gcc
            cc: gcc
            cxx: g++
          - compiler: clang
            cc: clang
            cxx: clang++

    steps:
    # perform sparse checkout excluding thirdparty to keep LFS pointers out of
    # the build container; thirdparty libs are downloaded separately anyway.
    - name: Sparse clone repository
      run: |
        git init .
        git remote add origin https://github.com/Flare-Animate/Flare.git
        git config core.sparseCheckout true
        echo "/*" > .git/info/sparse-checkout
        echo "!/thirdparty/*" >> .git/info/sparse-checkout
        git -c protocol.version=2 -c advice.detachedHead=false pull --depth=1 origin HEAD
      shell: bash

    - name: Install libraries
      run: |
        sudo apt-get update
        sudo apt-get install -y --no-install-recommends \
          build-essential cmake pkg-config ninja-build ccache \
          libboost-all-dev qtbase5-dev qt5-qmake qtscript5-dev \
          qttools5-dev qttools5-dev-tools qtmultimedia5-dev qtwayland5 \
          libqt5svg5-dev libqt5opengl5-dev libqt5multimedia5-plugins \
          libqt5serialport5-dev libsuperlu-dev liblz4-dev libusb-1.0-0-dev \
          liblzo2-dev libpng-dev libjpeg-dev libglew-dev freeglut3-dev \
          libfreetype6-dev libjson-c-dev libmypaint-dev libopencv-dev \
          libturbojpeg0-dev libomp-dev libfuse2

    - name: Set up ccache
      uses: hendrikmuhs/ccache-action@v1.2
      with:
        key: ${{ runner.os }}-${{ matrix.compiler }}
        max-size: "2G"

    - name: Build libtiff
      run: |
        cd thirdparty/tiff-4.0.3
        ./configure --disable-jbig --disable-shared --with-pic
        # Limitamos a 2 hilos para evitar que el OOM Killer cancele la operación
        make -j2 

    - name: Build Flare
      run: |
        cd flare
        mkdir -p build && cd build
        set +e
        cmake ../sources -G Ninja \
          -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
          -DCMAKE_C_COMPILER_LAUNCHER=ccache \
          -DCMAKE_CXX_COMPILER=${{ matrix.cxx }} \
          -DCMAKE_C_COMPILER=${{ matrix.cc }} \
          -DWITH_TRANSLATION=OFF \
          -DWITH_SYSTEM_LZO=ON \
          -DWITH_LZODRIVER=OFF \
          -DCMAKE_BUILD_TYPE=Release > cmake_configure.log 2>&1
        rc=$?
        set -e
        echo "--- Begin CMake configure log ---"
        if [ -f cmake_configure.log ]; then cat cmake_configure.log; fi
        echo "--- End CMake configure log ---"
        if [ $rc -ne 0 ]; then echo "CMake configure failed with exit code $rc"; exit $rc; fi

        # Ninja por defecto usa todos los núcleos; aquí lo limitamos a 2
        if ! (ninja -j2 2>&1 | tee build.log); then
          echo "Build failed; dumping build log..."
          if [ -f build.log ]; then cat build.log; fi
          exit 1
        fi

    - name: Upload build logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: build-logs-${{ matrix.compiler }}
        path: |
          flare/build/cmake_configure.log
          flare/build/build.log
        if-no-files-found: ignore

    - name: Create Artifact
      env:
        APPIMAGE_EXTRACT_AND_RUN: 1
      run: |
        cd flare/build
        sudo ninja install
        
        mkdir -p appdir/usr
        cp -r /opt/opentoonz/* appdir/usr
        # Evitar fallos si no existen iconos/desktops
        cp appdir/usr/share/applications/*.desktop appdir/ || true
        cp appdir/usr/share/icons/hicolor/256x256/apps/*.png appdir/ || true

        mkdir artifact
        if [ -d "appdir/usr/share/opentoonz/stuff" ]; then
          mv appdir/usr/share/opentoonz/stuff artifact/portablestuff
          rmdir appdir/usr/share/opentoonz || true
        fi

        # Descarga silenciosa y con reintentos
        base_url="https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous"
        for tool in linuxdeploy-x86_64.AppImage linuxdeploy-plugin-qt-x86_64.AppImage linuxdeploy-plugin-appimage-x86_64.AppImage; do
          wget -q --show-progress "${base_url}/${tool}" || \
          wget -q --show-progress "${base_url}/${tool}" || \
          wget -q --show-progress "${base_url}/${tool}"
          chmod +x "${tool}"
        done

        echo Copiando dependencias x64 (prefer flare, fallback to opentoonz)...
          if [ -d /opt/flare ]; then cp -r /opt/flare/* appdir/usr || true; elif [ -d /opt/opentoonz ]; then cp -r /opt/opentoonz/* appdir/usr || true; fi
          
          # Windows-specific DLL loops removed; not needed on Linux. If you really
          # need to copy any .dll files for compatibility, use a shell-friendly
          # construct such as:
          # find thirdparty -name "*.dll" -path "*64*" -exec cp {} FlarePortable/ \; || true
          # and similar for OpenCV paths.


        # Create apprun selecting either Flare or OpenToonz executable
        if [ -f appdir/usr/bin/Flare ]; then BINNAME=Flare; elif [ -f appdir/usr/bin/OpenToonz ]; then BINNAME=OpenToonz; else BINNAME=$(ls appdir/usr/bin | head -n1); fi
        printf "#!/usr/bin/env bash\nexec \"\${APPDIR}/usr/bin/${BINNAME}\"" > apprun.sh
        chmod 755 apprun.sh

        # Prefer lib path for flare if present, otherwise fallback
        if [ -d appdir/usr/lib/flare ]; then export LD_LIBRARY_PATH="appdir/usr/lib/flare:$LD_LIBRARY_PATH"; elif [ -d appdir/usr/lib/opentoonz ]; then export LD_LIBRARY_PATH="appdir/usr/lib/opentoonz:$LD_LIBRARY_PATH"; fi

        ./linuxdeploy-x86_64.AppImage --appdir=appdir --plugin=qt --output=appimage --custom-apprun=apprun.sh

        # Normalize appimage name to Flare.AppImage
        if ls Flare*.AppImage >/dev/null 2>&1; then mv Flare*.AppImage artifact/Flare.AppImage; elif ls OpenToonz*.AppImage >/dev/null 2>&1; then mv OpenToonz*.AppImage artifact/Flare.AppImage; fi
        ARTIFACT_NAME=Flare-${{ runner.os }}-${{ matrix.compiler }}
        mv artifact ${ARTIFACT_NAME} || true
        tar zcf ${ARTIFACT_NAME}.tar.gz ${ARTIFACT_NAME} || true

    - name: Upload
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: Flare-AppImage-${{ matrix.compiler }}
        path: flare/build/*.tar.gz

    - name: Post build logs to PR
      if: ${{ github.event_name == 'pull_request' && always() }}
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const pr = context.payload.pull_request ? context.payload.pull_request.number : undefined;
          if (!pr) { core.info('Not a pull_request event; skipping PR log posting.'); return; }
          function readTrunc(path) {
            try {
              if (!fs.existsSync(path)) return '(missing)';
              const content = fs.readFileSync(path, 'utf8');
              if (content.length > 12000) return content.slice(0, 6000) + '\n\n... (truncated) ...\n\n' + content.slice(-6000);
              return content;
            } catch (e) { return `(error reading ${path}): ${e.message}`; }
          }
          const cmake = readTrunc('flare/build/cmake_configure.log');
          const build = readTrunc('flare/build/build.log');
          const body = `**Automated build logs (truncated)**\n\n--- CMake configure log ---\n${cmake}\n\n--- Build log ---\n${build}`;
          await github.rest.issues.createComment({ owner, repo, issue_number: pr, body });

