#pragma once

#include <QtGlobal>
#include <QString>
#include <QVariant>
#include <QList>
#include <QObject>

// Minimal QtScript stubs used when QtScript headers are not available.
// These are kept in the project's include path so the project can compile
// on systems where QtScript is not installed. They intentionally provide
// only the symbols required for compilation and do not implement scripting.

class QScriptEngine;
class QScriptContext;

class QScriptValue {
public:
  QScriptValue() {}
  QScriptValue(int) {}
  QScriptValue(bool) {}
  QScriptValue(double) {}
  QScriptValue(const QString &) {}
  QScriptValue(QScriptEngine *, int = 0) {}

  QScriptValue property(const QString &) const { return QScriptValue(); }
  QScriptValue property(int) const { return QScriptValue(); }
  QScriptValue call(const QScriptValue &, const QList<QScriptValue> &) const { return QScriptValue(); }
  QString toString() const { return QString(); }
  QVariant toVariant() const { return QVariant(); }
  bool isNull() const { return true; }
  bool isUndefined() const { return true; }
};

typedef QList<QScriptValue> QScriptValueList;

class QScriptContext {
public:
  static QScriptContext *currentContext() { return nullptr; }
  QScriptEngine *engine() const { return nullptr; }
  QScriptValue argument(int) const { return QScriptValue(); }
  QScriptValue callee() const { return QScriptValue(); }
};

template <typename T>
T qscriptvalue_cast(const QScriptValue &) { return T(); }

class QScriptEngine {
public:
  enum Ownership { AutoOwnership = 0 };
  enum {
    ExcludeSuperClassContents = 0,
    ExcludeChildObjects = 0
  };

  typedef QScriptValue (*FunctionSignature)(QScriptContext *, QScriptEngine *);

  QScriptEngine() {}
  QScriptValue newObject() { return QScriptValue(); }
  QScriptValue newObject(const QScriptValue &) { return QScriptValue(); }
  QScriptValue newArray() { return QScriptValue(); }
  QScriptValue newFunction(FunctionSignature) { return QScriptValue(); }
  QScriptValue newQObject(QObject *, Ownership = AutoOwnership, int = 0) { return QScriptValue(); }
  QScriptValue newFunction(QScriptValue (*)(QScriptContext *, QScriptEngine *)) { return QScriptValue(); }
  QScriptValue evaluate(const QString &) { return QScriptValue(); }
  QScriptValue globalObject() { return QScriptValue(); }
};
